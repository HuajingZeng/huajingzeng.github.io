---
title: OOP概要
date: 2018-10-24 22:39:58
update:
author: 曾华经
tags:
	- 面向对象
	- 设计原则
	- 设计模式
categories:
	- 编程基础
thumbnail: /img/thumbnail/9.jpg
blogexcerpt:
toc: true
---

&emsp;&emsp;面向对象编程（Object-oriented programming）能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。
<!--more-->

---

# 基本特征

## 【抽象】
**Abstract**
> 抽象就是将一些事物的共性和相似点抽离出来，并将这些属性归为一个类，这个类只考虑这些事物的共性和相似之处，并且会忽略与当前业务和目标无关的那些方面，只将注意力集中在与当前目标有关的方面。

- 数据抽象：表示世界中一类事物的特征，就是对象的属性。比如鸟有翅膀、羽毛等（类的属性）
- 过程抽象：表示世界中一类事物的行为，就是对象的行为。比如鸟会飞、会叫（类的方法）

## 【封装】
**Encapsulation**
> 封装是为了隐藏内部实现细节，是保证软件部件具有优良的模块性的基础。封装的目标就是要实现软件部件“高内聚，低耦合”，防止程序之间的相互依赖性带来的变动影响。

## 【继承】
**Inheritance**
> 在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法（Override，重写方法）使之更适合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。

## 【多态】
**Polymorphism**
> 多态是运行时刻接口匹配的对象相互替换的能力。指程序定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译期并不确定，而是在程序运行期间才确定（称之为动态绑定），即一个引用变量指向的是哪个类的实例对象，在编译期间并不确定，在运行阶段才能决定，因此，这样就可以使得引用变量绑定到各种不同的类实现上，从而实现不同的行为。多态性增强了软件的灵活性和扩展性。 接口的多种不同的实现方式即为多态。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。

# 设计原则


## 【单一职责原则】
**Single Responsibility Principle**

每一个类应该专注于做一件事情。

## 【开闭原则】
**Open Close Principle**

面向扩展开放，面向修改关闭。

## 【里氏替换原则】
**Liskov Substitution Principle**

超类存在的地方，子类是可以替换的。

## 【依赖倒置原则】
**Dependence Inversion Principle**

实现尽量依赖抽象，不依赖具体实现。

## 【接口隔离原则】
**Interface Segregation Principle**

应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。

## 【迪米特法则/最少知识原则】
**Law Of Demeter**

一个软件实体应当尽可能少的与其他实体发生相互作用。

# 设计模式

> 设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。

<table style="text-align:center;vertical-align:middle;"><col span=5><tr><td colspan=2 rowspan=2></td><td colspan=3>目的</td></tr><tr><td>创建型</td><td>结构型</td><td>行为型</td></tr><tr><td rowspan=2>范围</td><td>类</td><td>工厂方法</td><td>适配器</td><td>解释器<br>模板方法</td></tr><tr><td>对象</td><td>抽象工厂<br>生成器<br>原型<br>单件</td><td>适配器<br>桥接<br>组成<br>装饰<br>外观<br>享元<br>代理</td><td>职责链<br>命令<br>迭代器<br>中介者<br>备忘录<br>观察者<br>状态<br>策略<br>访问者</td></tr></table>

## 【抽象工厂】
**Abstract Factory**
> 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

## 【适配器】
**Adaptor**
> 将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

## 【桥接】
**Bridge**
> 将抽象部分与它的实现部分分离，使它们都可以独立地变化。

## 【生成器】 
**Builder**
> 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

## 【职责链】 
**Chain of Responsibility**
> 为解除请求的发送者和接收者之间的耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。

## 【命令】 
**Command**
> 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排列或记录请求日志，以及支持可取消的操作。

## 【组成】 
**Composite**
> 将对象组合成树形结构以表示“部分-整体”的层次结构。使得客户对单个对象和复合对象的使用具有一致性。

## 【装饰】 
**Decorator**
> 动态地给一个对象添加一些额外的职责。就扩展功能而言，它比生成子类方式更加灵活。

## 【外观】 
**Facade**
> 为子系统中的一组接口提供一个一致的界面，它定义了一个高层接口，这个接口使得这一子系统更加容易使用。

## 【工厂方法】 
**Factory Method**
> 定义一个用于创建对象的接口，让子类决定将哪一个类实例化。它使一个类的实例化延迟到其子类。

## 【享元】 
**Flyweight**
> 运用共享技术有效地支持大量细粒度的对象。

## 【解释器】 
**Interpreter**
> 给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。

## 【迭代器】 
**Iterator**
> 提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。

## 【中介者】 
**Mediator**
> 用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

## 【备忘录】 
**Memento**
> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到保存的状态。

## 【观察者】 
**Observer**
> 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。

## 【原型】 
**Prototype**
> 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。

## 【代理】 
**Proxy**
> 为其他对象提供一个代理以控制对这个对象的访问。

## 【单件】 
**Singleton**
> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。

## 【状态】 
**State**
> 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。

## 【策略】 
**Strategy**
> 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。它使得算法的变化独立于使用它的客户。

## 【模板方法】 
**Template Method**
> 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。它使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。

## 【访问者】 
**Visitor**
> 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。



**欢迎转载，转载请注明出处：[曾华经的博客](http://www.huajingzeng.com)**

