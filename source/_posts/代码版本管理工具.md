---
title: 代码版本管理工具
date: 2018-01-13 09:08:39
update: 2018-01-13 09:08:39
author: 曾华经
tags: 
	- Git
	- SVN
	- CVS
categories: 
	- 编程基础
	- 开发工具
thumbnail: https://githubblog-1252104787.cos.ap-guangzhou.myqcloud.com/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.jpg
blogexcerpt:
toc: true
---
&emsp;&emsp;Git是一个开源的分布式版本控制系统。
&emsp;&emsp;SVN（Subversion）是一个开源的集中式版本控制系统。
&emsp;&emsp;CVS（Concurrent Versions System）是一个开源的版本控制系统，已逐渐被SVN取代。

<!--more-->

# 关于版本控制

> 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。

## 本地版本控制系统

![本地版本控制系统](https://githubblog-1252104787.cos.ap-guangzhou.myqcloud.com/%E6%9C%AC%E5%9C%B0%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.png)

## 集中化的版本控制系统

![集中化的版本控制系统](https://githubblog-1252104787.cos.ap-guangzhou.myqcloud.com/%E9%9B%86%E4%B8%AD%E5%8C%96%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.png)

## 分布式版本控制系统

![分布式版本控制系统](https://githubblog-1252104787.cos.ap-guangzhou.myqcloud.com/%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.png)

# Git

## 起步

### 存储方式

不同于其他版本控制系统，Git直接记录快照，而非差异比较

![](https://githubblog-1252104787.cos.ap-guangzhou.myqcloud.com/%E5%AD%98%E5%82%A8%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%8E%E5%88%9D%E5%A7%8B%E7%89%88%E6%9C%AC%E7%9A%84%E5%B7%AE%E5%BC%82.png)

![](https://githubblog-1252104787.cos.ap-guangzhou.myqcloud.com/%E5%AD%98%E5%82%A8%E9%A1%B9%E7%9B%AE%E9%9A%8F%E6%97%B6%E9%97%B4%E6%94%B9%E5%8F%98%E7%9A%84%E5%BF%AB%E7%85%A7.png)

### 完整性和安全性

- 所有数据在存储前都计算校验和，计算校验和的机制叫做SHA-1散列（hash，哈希）。这是一个由40个十六进制字符（0-9和a-f）组成字符串（如`1a0a05cf10a6630f23aa83ef2d61394f17c869`），基于文件的内容或目录结构计算出来。Git保存的信息都是以文件内容的哈希值来索引，而不是文件名。若你在传送过程中丢失信息或损坏文件，Git就能发现
- 执行的Git操作，几乎只往数据库中增加数据。很难执行任何不可逆操作，或者以任何方式清除数据（除非执行撤销操作）

### 文件状态

- 已提交（committed）：表示数据已经安全的保存在本地数据库中
- 已修改（modified）：修改了文件，但还没保存到数据库中
- 已暂存（staged）：对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中

![工作目录、暂存区域以及 Git 仓库](https://githubblog-1252104787.cos.ap-guangzhou.myqcloud.com/%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E3%80%81%E6%9A%82%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%BB%A5%E5%8F%8A%20Git%20%E4%BB%93%E5%BA%93.png)

### 工作流程

- 在工作目录中修改文件
- 暂存文件，将文件的快照放入暂存区域
- 提交更新，找到暂存区域的文件，将快照永久性存储到Git仓库目录

### 使用方式

- 命令行模式：终端（Mac）、命令窗口（Win）
- GUI模式：Sourcetree(Mac)

**PS：推荐使用命令行模式，因为只有在命令行模式下你才能执行Git的所有命令，而大多数的GUI软件只实现了Git所有功能的一个子集以降低操作难度**

## 安装

略

## 配置

Git自带一个`git config`的工具来帮助设置控制Git外观和行为的配置变量。 这些变量存储在三个不同的位置：

- `/etc/gitconfig`文件: 包含系统上每一个用户及他们仓库的通用配置。可以使用带有`--system`选项的`git config`对此文件进行读写和变量配置
- `~/.gitconfig`或`~/.config/git/config`文件：只针对当前用户。可以使用带有`--global`选项的`git config`对此文件进行读写和配置
- `.git/config`文件：只针对该Git仓库。

**注意：每一个级别会覆盖上一级别的配置**

### 配置用户信息

```
$ git config --global user.name "Kevin Zeng"
$ git config --global user.email zenghuajing@qq.com
```

### 配置文本编辑器

```
$ git config --global core.editor vim
```

### 检查配置信息

列出所有Git当时能找到的配置

```
$ git config --list
```

检查Git的某一项配置

```
$ git config user.name
```

### 帮助

获得帮助信息

```
$ git help <verb>
$ git <verb> --help
$ man git-<verb>
```

## 基础

### 获取Git仓库

#### 创建新仓库

在现有项目或目录下导入所有文件到Git中：

```
$ git init
```

该命令将创建一个名为`.git`的子目录，这个子目录含初始化的Git仓库中所有的必须文件，这些文件是Git仓库的骨干。但是，在这个时候，项目里的文件还没有被跟踪。可通过`git add`命令来实现对指定文件的跟踪，然后执行`git commit`提交：

```
$ git add *.[hm]
$ git add README
$ git commit -m 'initial project version'
```

#### 克隆现有仓库

获得一份已经存在了的Git仓库的拷贝

```
$ git clone https://github.com/HuajingZeng/huajingzeng.github.io
```

这会在当前目录下创建一个名为“huajingzeng.github.io”的目录，并在这个目录下初始化一个`.git`文件夹，从远程仓库拉取下所有数据放入`.git`文件夹，然后从中读取最新版本的文件的拷贝。你也可以在克隆远程仓库的时候，自定义本地仓库的名字，比如：

```
$ git clone https://github.com/HuajingZeng/huajingzeng.github.io githubblog
```

**Git支持多种数据传输协议：**

- https://协议
- git://协议
- SSH传输协议，比如 user@server:path/to/repo.git

### 记录更新

![文件的状态变化周期](https://githubblog-1252104787.cos.ap-guangzhou.myqcloud.com/%E6%96%87%E4%BB%B6%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E5%91%A8%E6%9C%9F.png)

#### 检查当前文件状态

查看哪些文件处于什么状态

```
$ git status
```

#### 跟踪新文件

开始跟踪一个文件

```
$ git add file1 file2 ...
```

**注意：`git add`命令使用文件或目录的路径作为参数，如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件**

#### 暂存已修改文件

`git add`是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。

#### 状态简览

可以使用`git status -s`命令或`git status --short`命令得到更为紧凑的格式输出

```
$ git status -s
 M text.c
MM main.m
A  marco.h
M  README
?? a.out
```

新添加的未跟踪文件前面有`??`标记，新添加到暂存区中的文件前面有`A`标记，修改过的文件前面有`M`标记。 你可能注意到了`M`有两个可以出现的位置，出现在右边的`M`表示该文件被修改了但是还没放入暂存区，出现在靠左边的`M`表示该文件被修改了并放入了暂存区。

#### 忽略文件

一般我们总会有些文件无需纳入Git的管理，也不希望它们总出现在未跟踪文件列表。在这种情况下，我们可以创建一个名为`.gitignore`的文件，列出要忽略的文件模式。文件`.gitignore`的格式规范如下：

- 所有空行或者以`＃`开头的行都会被Git忽略
- 可以使用标准的`glob`模式匹配
- 匹配模式可以以`/`开头防止递归
- 匹配模式可以以`/`结尾指定目录
- 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号`!`取反

所谓的`glob`模式是指shell所使用的简化了的正则表达式（参见[神兵利器之正则表达式](http://www.huajingzeng.com/post/%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/)）

**GitHub有一个十分详细的针对数十种项目及语言的`.gitignore`文件列表，你可以在[https://github.com/github/gitignore](https://github.com/github/gitignore)找到它**

#### 查看已暂存和未暂存的修改

可以用`git diff`命令查看具体修改了什么地方

- 要查看尚未暂存的文件更新了哪些部分，不加参数直接输入`git diff`
- 若要查看已暂存的将要添加到下次提交里的内容，可以用`git diff --cached`命令（Git 1.6.1 及更高版本还允许使用`git diff --staged`，效果是相同的，但更好记些）

**如果你喜欢通过图形化的方式或其它格式输出方式的话，可以使用`git difftool`命令来用 Araxis，emerge或vimdiff等软件输出diff分析结果。使用`git difftool --tool-help`命令来看你的系统支持哪些Git Diff插件**

#### 提交更新

运行提交命令`git commit`会启动文本编辑器以便输入本次提交的说明。(默认会启用shell的环境变量&#36;EDITOR所指定的软件，一般都是vim或emacs。当然也可以使用`git config --global core.editor`命令设定你喜欢的编辑软件）。另外，也可以在`git commit`命令后添加`-m`选项，将提交信息与命令放在同一行

```
$ git commit -m "Modify and add files."
[master 463dc4f] Modify and add files.
 2 files changed, 2 insertions(+)
 create mode 100644 README
```

提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整SHA-1校验和是什么（463dc4f），以及在本次提交中，有多少文件修订过，多少行添加和删改过等信息。

**注意：每次准备提交前，先用`git status`看下，是不是都已暂存起来了，然后再使用`git commit`提交。提交时记录的是放在暂存区域的快照。任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。**

#### 跳过使用暂存区域

只要在提交的时候，给`git commit`加上`-a`选项，Git就会，自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过`git add`步骤（即跳过使用暂存区域的方式）

#### 移除文件

要从Git中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用`git rm`命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。

如果只是简单地从工作目录中手工删除文件，运行`git status`时就会在“Changes not staged for commit” 部分（也就是未暂存清单）看到提示信息：

```
$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use "git add" and/or "git commit -a")
```

然后再运行`git rm`记录此次移除文件的操作：

```
$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    deleted:    PROJECTS.md
```

如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项`-f`（译注：即force的首字母）。这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被Git恢复。

另外一种情况是，我们想把文件从Git仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中使用`--cached`选项

```
$ git rm --cached README
```

#### 移动文件

Git并不显式跟踪文件移动操作。如果在Git中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。要在Git中对文件改名，可以这么做：

```
$ git mv file_from file_to
```

其实，运行`git mv`就相当于运行了下面三条命令：

```
$ mv README.md README
$ git rm README.md
$ git add README
```

**注意：直接用`git mv`轻便得多。不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名**

### 查看提交历史

默认不用任何参数的话，`git log`会按提交时间列出所有的更新，最近的更新排在最上面。这个命令会列出每个提交的SHA-1校验和、作者的名字和电子邮件地址、提交时间以及提交说明。你可以使用如下选项定制输出格式：

- `-p`：按补丁格式显示每个更新之间的差异
- `--stat`：显示每次更新的文件修改统计信息
- `--shortstat`：只显示`--stat`中最后的行数修改添加移除统计
- `--name-only`：仅在提交信息后显示已修改的文件清单
- `--name-status`：显示新增、修改、删除的文件清单
- `--abbrev-commit`：仅显示SHA-1的前几个字符，而非所有的40个字符
- `--relative-date`：使用较短的相对时间显示（比如，“2 weeks ago”）
- `--graph`：显示 ASCII 图形表示的分支合并历史
- `-(n)`：仅显示最近的n条提交
- `--since`，`--after`：仅显示指定时间之后的提交
- `--until`，`--before`：仅显示指定时间之前的提交
- `--author`：仅显示指定作者相关的提交
- `--committer`：仅显示指定提交者相关的提交
- `--grep`：仅显示含指定关键字的提交
- `-S`：仅显示添加或移除了某个关键字的提交
- `--pretty`：使用其他格式显示历史提交信息。可用的选项如下
	- `oneline`：将每个提交放在一行显示
	- `short`：
	- `full`：
	- `fuller`：
	- `format `：定制要显示的记录格式，如`git log --pretty=format:"%h %s"`

|选项|说明|
|:---:|:---|
|%H|提交对象的完整哈希字串|
|%T|提交对象的简短哈希字串|
|%t|树对象的完整哈希字串|
|%p|父对象的完整哈希字串|
|%P|父对象的简短哈希字串|
|%an|作者（author）的名字|
|%ae|作者的电子邮件|
|%ad|作者修订日期（可以用`--date=`选项定制格式）|
|%ar|作者修订日期，按多久以前的方式显示|
|%cn|提交者（committer）的名字|
|%ce|提交者的电子邮件地址|
|%cd|提交日期|
|%cr|提交日期，按多久以前的方式显示|
|%s|提交说明|

**作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人**

### 撤销操作

可以运行带有`--amend`选项的提交命令尝试重新提交。这个命令会将暂存区中的文件提交。如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。文本编辑器启动后，可以看到之前的提交信息。编辑后保存会覆盖原来的提交信息。

```
$ git commit --amend
```

如果提交后发现忘记了暂存某些需要的修改，可以像下面这样操作，最终只会有一个提交，即第二次提交将代替第一次提交的结果。

```
$ git commit -m 'initial commit'
$ git add forgotten_file
$ git commit --amend
```

#### 取消暂存的文件

```
$ git reset HEAD <file>...
```

**PS：在调用时加上`--hard`选项可以令`git reset`成为一个危险的命令（可能导致工作目录中所有当前进度丢失！）**

#### 撤消对文件的修改

来撤消之前所做的修改，将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）

```
$ git checkout -- file1 file2 ...
```

**PS：`git checkout -- <file>`是一个危险的命令，你对那个文件做的任何修改都会消失，你只是拷贝了另一个文件来覆盖它。除非你确实清楚不想要那个文件了，否则不要使用这个命令**

**注意：在Git中任何已提交的东西几乎总是可以恢复的。甚至那些被删除的分支中的提交或使用`--amend`选项覆盖的提交也可以恢复。然而，任何你未提交的东西丢失后很可能再也找不到了**

### 远程仓库的使用

> 远程仓库是指托管在因特网或其他网络中的你的项目的版本库

#### 查看远程仓库

查看你已经配置的远程仓库服务器，可以运行`git remote`命令。它会列出你指定的每一个远程服务器的简写，如origin（这是Git给你克隆的仓库服务器的默认名字）。也可以指定选项`-v`，会显示需要读写远程仓库使用的Git保存的简写与其对应的URL。如果远程仓库不止一个，该命令会将它们全部列出。

#### 添加远程仓库

添加一个新的远程Git仓库，同时指定一个引用的简写。添加之后你可以在命令行中使用字符串`<shortname>`来代替整个URL。

```
$ git remote add zhj https://www.github.com/HuajingZeng/huajingzeng.github.io
```

#### 从远程仓库中抓取与拉取

访问远程仓库，从中拉取数据。如果你使用`clone`命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。

```
$ git fetch https://www.github.com/HuajingZeng/huajingzeng.github.io
$ git fecth origin
```

**PS：`git fetch`命令会将数据拉取到你的本地仓库，它并不会自动合并或修改你当前的工作**

可以使用`git pull`命令来自动的抓取然后合并远程分支到当前分支。默认情况下，`git clone`命令会自动设置本地master分支跟踪克隆的远程仓库的master分支（或不管是什么名字的默认分支）

#### 推送到远程仓库

使用`git push [remote-name] [branch-name]`推送本地仓库到远程仓库

```
$ git push origin master
```

**注意：只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送**

#### 查看远程仓库

```
$ git remote show origin
```

#### 远程仓库的移除与重命名

重命名远程仓库的简写名

```
$ git remote rename zhj ZHJ`
```

移除远程仓库

```
$ git remote rm zhj
```

### 打标签

Git可以给历史中的某一个提交打上标签，以示重要。比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。

#### 列出标签

```
$ git tag
```

你也可以使用特定的模式（如正则表达式）查找标签

```
$ git tag -l 'v1.8.5*'
```

#### 创建标签

Git的标签类型有两种：

- 轻量标签（lightweight）：很像一个不会改变的分支，它只是一个特定提交的引用
- 附注标签（annotated）：存储在Git数据库中的一个完整对象。它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用GNU Privacy Guard （GPG）签名与验证。 

**通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。**

##### 附注标签

创建一个附注标签，并指定标签信息与对应的提交信息

```
$ git tag -a v1.4 -m "my version 1.4"
```

查看标签信息与对应的提交信息

```
$ git show v1.4
```

##### 轻量标签

轻量标签本质上是将提交校验和存储到一个文件中，没有保存任何其他信息。创建轻量标签，不需要使用`-a`、`-s`或`-m`选项，只需要提供标签名字

```
$ git tag v1.4-lw
```

#### 后期打标签

在某个提交上打标签，只需要在命令的末尾指定提交的校验和（或部分校验和）

```
$ git tag -a v1.2 9fceb02
```

#### 共享标签

默认情况下，`git push`命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。 

```
$ git push origin v1.4
```

如果想要一次性推送很多标签，也可以如下命令

```
$ git push origin --tags
```

#### 检出标签

在Git中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。如果你想要工作目录与仓库中特定的标签版本完全一样，可以在特定的标签上创建一个新分支

```
$ git checkout -b origin v1.4 
```

### Git别名

Git并不会在你输入部分命令时自动推断出你想要的命令。如果不想每次都输入完整的Git命令，可以通过`git config`文件来轻松地为每一个命令设置一个别名

```
$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status
```

你可能想要执行外部命令，而不是一个Git子命令。如果是那样的话，可以在命令前面加入`!`符号

```
$ git config --global alias.visual '!gitk'
```

## Git分支

### 分支的创建与切换

创建testing分支

```
$ git branch testing
```

切换到testing分支

```
$ git checkout testing
```

创建并切换到testing分支（等价于同时使用上述两个命令）

```
$ git checkout -b testing
```

### 分支的合并

将testing分支合并入master

```
$ git checkout master
$ git merge testing
```

### 查看分支

查看当前分支列表

```
$ git branch
```

查看每一个分支的最后一次提交

```
$ git branch -v
```

查看哪些分支已经合并到当前分支

```
$ git branch --merged
```

查看所有包含未合并工作的分支

```
$ git branch --no-merged
```

删除testing分支

```
$ git branch -d testing
```

### 远程分支

> 远程引用是对远程仓库的引用（指针），包括分支、标签等等

你可以通过`git ls-remote (remote)`来显式地获得远程引用的完整列表，或者通过`git remote show (remote)`获得远程分支的更多信息。远程分支以`(remote)/(branch)`形式命名。

#### 克隆远程仓库

使用`git clone`命令克隆远程仓库时默认会在本地创建`origin/master`的远程分支。远程分支名字`origin`与分支名字`master`一样，在Git中并没有任何特别的含义。`master`是运行`git init`时默认的起始分支名字，原因仅仅是它的广泛使用，`origin`是运行`git clone`时默认的远程仓库名字。如果你运行`git clone -o zhj`，那么你默认的远程分支名字将会是`zhj/master`

#### 更新远程仓库引用

可以运行`git fetch origin`查找`origin`是哪一个服务器，从中抓取本地没有的数据，并且更新本地数据库，移动`origin/master`指针指向新的、更新后的位置。

#### 添加远程仓库

使用`git remote add teamone git://git.team1.ourcompany.com`

#### 推送分支到远程仓库

运行`git push origin bugfix`可以将当前本地分支推送到远程仓库。Git自动将`bugfix`分支名字展开为`refs/heads/bugfix:refs/heads/bugfix`，即“推送本地的bugfix分支来更新远程仓库上的bugfix分支。等价于使用`git push origin bugfix:bugfix`

#### 跟踪分支

为远程分支指定本地分支名

```
$ git checkout -b branch origin/master
```

使用默认的分支名跟踪远程分支

```
$ git checkout --track origin/master
```

设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用`-u`或`--set-upstream-to`选项运行`git branch`来显式地设置

```
$ git branch -u origin/bugfix
```

所有的本地分支列出来并且包含更多的信息

```
$ git branch -vv
```

#### 拉取

`git pull`在大多数情况下它的含义是一个`git fetch`紧接着一个`git merge`命令。`git pull`会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。

#### 删除远程分支

```
$ git push origin --delete bugfix
```

### 变基

将分支iss52变基到分支master

```
$ git checkout iss52
$ git rebase master
```

# SVN

# CVS

**欢迎转载，转载请注明出处：[曾华经的博客](http://www.huajingzeng.com)**
