---
title: Shell脚本编程
date: 2017-11-25 09:24:43
update: 2017-11-25 09:24:43
author: 曾华经
tags: 
	- Shell
categories: 
	- 编程基础
	- 开发工具
thumbnail: /img/thumbnail/1.jpg
blogexcerpt:
toc: true
---
&emsp;&emsp;Shell是类Unix系统下一个实用的工具程序，它有自己内建的编程语言（解释型）。Shell会分析所遇到的每一条语句，然后执行所发现的有效命令。这与C++及Swift这类编程语言（编译型）不同，这些语言的程序语句在执行之前通常都会被编译成可由机器执行的形式。

&emsp;&emsp;Shell脚本（Shell Script），是一种为Shell编写的脚本程序。我们通常说的“Shell编程”都是指Shell脚本编程，不是指开发Shell自身。
<!--more-->

# 常用命令

|<div style="white-space: nowrap; word-wrap: normal; word-break: normal;">&emsp;&emsp;命令&emsp;&emsp;<div>|描述|
|:---:|---|
|cat file(s)|显示一个或多个文件的内容，如果没有提供参数的话，则显示标准输入内容|
|cd dir|将当前工作目录更改为dir|
|cp file1 file2|将file1复制到file2|
|cp file(s) dir|将一个或多个文件复制到dir中|
|date|显示日期和时间|
|echo args|显示给出的一个或多个参数|
|ln file1 file2|将file1链接到file2|
|ln file(s) dir|将一个或多个文件链接到dir中|
|ls file(s)|列出一个或多个文件|
|ls dir(s)|列出一个或多个目录中的文件，如果没有指定目录，则列出当前目录中的文件|
|mkdir dir(s)|创建一个或多个指定的目录|
|mv file1 file2|移动file1并将其重命名为file2（如果均处于相同目录下，则仅执行重命名操作）|
|mv file(s) dir|将一个或多个文件移动到指定目录dir中|
|ps|列出活动进程的信息|
|pwd|显示出当前工作目录的路径|
|rm file(s)|删除一个或多个文件|
|rmdir dir(s)|删除一个或多个目录|
|sort file(s)|将一个或多个文件中的行进行排序，如果没有指定文件，则对标准输入内容进行排序|
|wc file(s)|统计一个或多个文件中的行数、单词数和字符数，如果没有指定文件的话，则统计标准输入中的内容|
|who|显示出已登录的用户|

关于这些命令的用法，详见：[常用Shell命令](/post/常用Shell命令)

# 基础概念

## 程序（命令）执行

Shell会根据输入的内容进行分析，然后决定执行什么操作。Shell是按行进行分析的，每行都遵循以下的基本格式：

```sh
command [argument1] [argument2] ...
```

Shell使用空白字符（whitespace characters，包括空格符、水平制表符和换行符）来确定命令名称和每个参数的起止，连续的多个空白字符会被Shell忽略。

Shell会扫描命令行，提取行首到第一个空白字符之间的所有内容作为待执行的命令名称command，随后的空白字符（多余的空格）会被忽略，直到下一个空白字符之间的字符作为第一个参数argument1，再到下一个空白字符之间的字符作为第二个参数argument2，如此继续直到该命令行结束。解析完命令行之后，Shell就开始执行命令名称指定的程序，并将命令名称之后的参数传递给该程序

## 文件名替换
Shell在确定要执行的命令及其参数之前，会扫描命令行，查找文件名替换字符*、？或[...]

|替换字符|说明|
|:---:|---|
|*|匹配零个或多个字符|
|?|仅能匹配单个字符|
|[chars]/[char1-char2]|匹配指定字符集合中的某个字符|

## I/O重定向
Shell会扫描每一个命令行，从中找出特殊的重定向字符<、>、2>、<<、>>和2>>。

|重定向字符|说明|
|:---:|---|
|>|将命令行中的下一个单词作为标准输出重定向所指向的文件名|
|<|将命令行中的下一个单词作为标准输入重定向所指向的文件名|
|>>|同>|
|<<|同<|

## 管道
Shell在扫描命令行时，会查找管道字符|。每找到一个，就会将之前命令的标准输出连接到之后命令的标准输入。

## 标准错误
所有运行的Shell命令，都会有默认3个文件描述符:
- 标准输入（stdin，即standard input，文件描述符0）：命令的输入，默认指向键盘
- 标准输出（stdout，即standard output，文件描述符1）：命令执行结果的输出，默认指向终端（屏幕）
- 标准错误（stderr，即standard error，文件描述符2）：命令错误信息的输出，默认指向终端（屏幕）

标准错误默认是同终端或终端应用程序相关联的。标准错误无法通过输出重定向字符（>或>>）写入文件，必须使用特殊的输出重定向字符（2>或2>>）才能将其写入文件。

## 命令（脚本）文件
Shell命令可以直接在终端命令行中输入。也可以从文件中读取，然后由Shell执行该文件。在命令行中执行脚本之前，必须将文件权限修改为可执行：

```sh
$ chmod +x file(s)
```

然后执行该文件

```sh
$ file
```

**注意：如果解决了权限问题，仍旧得到错误信息“command not found”，尝试在命令文件前面加上./（如./file），确保Shell除了在常用的系统位置之外，也会在当前目录下查找命令。要想一劳永逸的话，把.添加到PATH环境变量（通常在.profile文件中）内容的末尾**

在Shell命令文件中使用#作为注释符，Shell会忽略#之后的内容

## 变量

### 变量赋值
Shell允许将值赋值给变量。变量名以字母或下划线开头，后面可以跟上零个或多个字母及数字字符或下划线，可以用正则表达式[A-Za-z_][a-zA-Z0-9_]*来匹配变量名。要将值保存在变量中，要先写出变量名，然后紧跟上等号=，接着是要存入变量的值：

```sh
$ variable=value
```

**注意：**
- Shell变量赋值等号的两边不能有空格
- Shell没有数据类型的概念，无论给Shell变量名分配什么样的值，Shell都简单地将其视为字符串

### 未定义变量
没有值的变量叫做未定义变量，未定义变量的值为null。Shell在扫描命令行时，会先执行替换操作，然后会忽略null。如果想将某个变量的值初始化为空值，只需要把等号右侧留空或者使用两个连续的引号就行：

```sh
$ variable1=
$ variable2=""
$ variable3=''
```

### 变量替换
只要变量名出现在美元符号$之后，Shell就会将其替换成对应的变量值：

```sh
$ echo $variable
value
```
**注意：**
- 在对变量赋值时，Shell并不执行文件名替换
- Shell扫描命令行时，先执行变量替换，然后是文件名替换，接着是将命令行解析成参数（Shell是在执行命令前进行变量替换的，所以即使是命令名也可以保存在变量中）

如果需要对替换后的变量值做特殊处理，比如加上字符X，则必须使用${variable}结构：

```sh
$ filename=test
// 将文件test重命名为testX
$ mv $filename ${filename}X
```

## 算术扩展
所有POSIX标准Shell提供一种叫做算术扩展（arithmetic expansion）的机制，能够用于执行Shell变量的整数运算。算术扩展的格式为：

```sh
$((expression))
```

其中expression是包含有效的Shell变量（不需要使用美元符号，但必须包含数字值，值的首部和尾部可以有空白字符。如果变量未定义或包含空串，其值被视为0）和操作符（与C语言中的运算符一样）的算术表达式。

也可以使用数学等式解算器[expr](/post/常用Shell命令/#expr)（mathematical equation solver）命令对算术表达式进行运算。使用此命令时操作数和操作符之间必须用空格分隔。

**注意：expr只能够求值整数算术表达式，如果要进行浮点数运算的话，可以使用[awk](/post/常用Shell命令/#awk)或[bc](/post/常用Shell命令/#bc)**

## 引用

Shell能够识别4种不同的引用字符：单引号'、双引号"、反斜线\、反引号`（单引号、双引号和反引号必须成对出现）。

### 单引号
只要Shell碰到第一个'，在遇到用于封闭的'之前，它不会再解释任何特殊字符（即使是Enter键也会被保留并作为命令参数的一部分）。

```sh
$ echo 'How are you today,
> John'
How are you today,
John
$
```

**注意：此处的>叫做辅助提示符（secondary prompt character），Shell会在等待用户完成多行命令的输入时显示该提示符**

### 双引号
双引号会忽略美元符号$、反引号`、反斜线\这3个字符之外的特殊字符。

```sh
$ filelist=*
$ echo $filelist
test.txt test1.txt test2.txt
$ echo '$filelist'
$filelist
$ echo "$filelist"
*
$
```

**双引号还可以用来保留单引号，反之亦然**

### 反斜线
- 反斜线作为前缀使用时在功能上相当于在单个字符周围放置单引号（反斜线可以对紧随其后的字符进行转义）。
- 如果反斜线是输入行的最后一个字符，Shell将其视为续航符（它会删除随后的换行符，也不会将该换行符作为参数分隔符，就好像这个字符从没出现过）
- 在双引号中使用反斜线可以去除会被Shell解释的那些字符的特殊含义（反斜线、美元符号、反引号、换行符以及其他的双引号）。如果反斜线出现在双引号中其他字符之前，Shell会将该反斜线忽略，继续往后处理

### 反引号
反引号也被称为“反撇号”，它告诉Shell将其中的命令使用命令输出代替（命令输出会被插入到它的当前所在位置）。其格式为：

```sh
`command`
```

所有现代POSIX兼容的Shell都支持一种新的命令替换写法（括号中可以调用多个命令，命令之间使用分号隔开，可以使用管道）：

```sh
$(command)
```

## 参数传递

### 变量$1~${n}
执行Shell程序时，Shell会自动将第n个参数保存在特殊的Shell变量（这些特殊变量叫位置参数，因为它们是基于参数在命令行中所处的位置）${n}中，这些特殊变量是在Shell完成正常的命令行处理之后（I/O重定向、变量替换、文件名替换等）被赋值的。

```sh
$ cat ./myScript
echo $1 $2
$ ./myScript param1 param2
param1 param2
```

**注意：如果给程序提供的参数多余9个，第10个以后的参数（含第10个），必须使用${n}的变量形式(否则Shell会把$10替换成$1的值并在后面加上一个0）。你也可以理解为标准形式就是${n}，当n是个位数时可以省略大括号{}。**

### 变量$<span>#</span>
特殊Shell变量$#包含了命令行中输入的参数个数

```sh
$ cat ./myScript
echo $#
$ ./myScript param1 param2
2
```

### 变量$*
特殊Shell变量$*引用的是传给程序的所有参数，即$1、$2...

```sh
$ cat ./myScript
echo $*
$ ./myScript param1 param2
param1 param2
```

### 变量$@
同$\*，如果使用变量"$@"，则其传入程序中的值是"$1"、"$2"...如果没有了双引号，该变量的效果与$*无异

## 条件语句
### if、elif、else语句
一般格式为：

```sh
if command1
then
	command
	...
elif command2
then
	command
	...
else
	command
	...
fi
```

### case语句
一般格式为：

```sh
case value in
pattern1) command
			command
			...
			command;;
pattern2) command
			command
			...
			command;;
...
pattern3) command
			command
			...
			command;;
esac			
```

### 退出状态
每一个命令执行完成，就会向Shell返回一个退出状态码。这个退出状态码是一个数值，指明了运行是否成功。为0的退出状态码表示运行成功；非0的退出状态码表示运行失败，不同的值对应不同的失败原因。

### 变量$?
Shell会将变量$?自动设置为最后一条命令的退出状态

**注意：对一些命令来说，其表示“执行失败”的数值在不同的系统版本中并不相同，但表示执行成功的退出状态总是0**

### test命令
```sh
test expression
```

另外一种格式为（在“[”之后以及“]”之前必须有空格）：

```sh
[ expression ]
```


### exit命令
exit命令可以立即终止Shell程序的执行，其一般格式为

```sh
exit n
```

其中，n是返回的退出状态码，如果没有指定，则使用在exit之前最后执行的那条命令的退状态（即exit $?）

**注意：如果直接在终端中执行exit命令，会使你登出系统，因为它相当于终止了你的登录Shell**

### &&和||
```sh
command1 && command2
```

如果command1命令返回的退出状态码为0（成功），则接着执行command2。如果command1返回的退出状态码不为0（失败），command2会被忽略。

```sh
command1 || command2
```

command2命令仅在command1命令的退出状态码非0的时候才执行。

## 循环语句

### for命令
```sh
for var (in word1 word2 ... wordn)
do
	command
	...
done
```

do与done之间的命令叫做循环体，其执行的次数由in后面的列表条目个数而定。在执行循环时，word列表中的值分别赋给变量var，然后执行循环体。

**注意：使用for命令时，若忽略in以及后续的列表，则默认使用in "$@"**

### while命令
```sh
while command0
do
	command
done
```

只要command0表达式返回非0，则退出循环。

### until命令
```sh
until command0
do
	command
done
```

只要command0表达式返回0，则退出循环。

### break命令
在循环体中使用break命令可以立即退出循环语句。使用下面的形式，可以立即退出第n层内循环。

```sh
break n
```

### continue命令
类似于break，不同的地方在于它不会退出整个循环，而只是跳过当前迭代中剩下的命令，然后程序立即进入下一次迭代。continue后面也可以加上一个可选的数字，用以跳过最内侧的n个循环中的命令。

```sh
continue n
```

### 循环上的I/O重定向
在循环关闭语句done之后，可以使用重定向操作符进行输出重定向。

### getopts命令
```sh
getopts options option
```

**options**：单字母选项组成的字符串，如果该选项需要参数，则要在后面加上冒号（如ab:c表示-a、-b、-c，-b需要另外指定参数）
**option**：用来存放每个匹配值的变量名

在每次循环中，getopts都会检查下一个命令行参数，通过查看该参数是否以减号开头，随后是否是在options中指定的字符来决定选项是否有效。如果没有问题，getopts就会将匹配的选项字母保存在指定的option中，然后返回为0的退出状态码。如果减号后面的字符没有在options中列出，getopts会返回非0的退出状态码。

- 如果getopts没有在选项后找到要求的参数，它会将问号保存到变量中并向标准错误中输出错误信息。否则，就将选项字符保存在变量中，把用户指定的参数放在一个叫做OPTARG的特殊变量中。
- 特殊变量OPTIND的初始值为1，随后每当getopts返回时都会被更新为下一个要处理的命令行参数的序号。

## 数据的读取和打印
### read命令
```sh
read variables
```

该命令执行时，Shell会从标准输入中读取一行，然后将单词分配给variables中列出的变量。如果行中的单词多于列表中的变量，则多出的单词全部分配给最后一个变量。

# 其他
## 系统的“垃圾桶”
/dev/null是一个特殊的系统文件，任何人都可以读取（立刻会得到一个EOF）或写入。向该文件写入的任何东西都会消失，就像是一个巨大的黑洞一样。

## 终端程序
/dev/tty总是指向终端程序，不管是Mac、Linux还是Unix系统。

## 调试选项 -x
想调试Shell程序，或是了解更多的工作原理，可以在程序正常的调用（命令名及参数）之前输入sh -x以跟踪执行过程（命令在执行的同时会被打印在终端中，并在之前加上一个加号）。

## 空命令:
该命令什么都不做，它用来满足必须有命令存在的要求。

## 续行符\
当\用于行尾的时候表示续行。

## 后台运行符&
当&用于行尾的时候表示在后台运行该程序或命令（默认情况下，从系统登出时，所有的进程都会自动终止。如果希望某个程序在登出后仍然继续执行，可以使用nohup命令运行该程序，或者使用at/cron来调度执行）

**循环语句也可以在后台执行，只需要在done语句后加上一个&就可以了**

**PS：待补充更新...**

**欢迎转载，转载请注明出处：[曾华经的博客](http://www.huajingzeng.com)**
