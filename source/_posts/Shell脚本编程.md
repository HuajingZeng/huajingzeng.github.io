---
title: Shell脚本编程
date: 2017-11-25 09:24:43
update: 
author: 曾华经
tags: 
	- Shell
categories: 
	- 编程基础
	- 开发工具
thumbnail: /img/thumbnail/1.jpg
blogexcerpt:
toc: true
---
&emsp;&emsp;Shell是类Unix系统下一个实用的工具程序，它有自己内建的编程语言（解释型）。Shell会分析所遇到的每一条语句，然后执行所发现的有效命令。这与C++及Swift这类编程语言（编译型）不同，这些语言的程序语句在执行之前通常都会被编译成可由机器执行的形式。

&emsp;&emsp;Shell脚本（Shell Script），是一种为Shell编写的脚本程序。我们通常说的“Shell编程”都是指Shell脚本编程，不是指开发Shell自身。
<!--more-->

# 常用命令

|<div style="white-space: nowrap; word-wrap: normal; word-break: normal;">&emsp;&emsp;命令&emsp;&emsp;<div>|描述|
|:---:|---|
|cat file(s)|显示一个或多个文件的内容，如果没有提供参数的话，则显示标准输入内容|
|cd dir|将当前工作目录更改为dir|
|cp file1 file2|将file1复制到file2|
|cp file(s) dir|将一个或多个文件复制到dir中|
|date|显示日期和时间|
|echo args|显示给出的一个或多个参数|
|ln file1 file2|将file1链接到file2|
|ln file(s) dir|将一个或多个文件链接到dir中|
|ls file(s)|列出一个或多个文件|
|ls dir(s)|列出一个或多个目录中的文件，如果没有指定目录，则列出当前目录中的文件|
|mkdir dir(s)|创建一个或多个指定的目录|
|mv file1 file2|移动file1并将其重命名为file2（如果均处于相同目录下，则仅执行重命名操作）|
|mv file(s) dir|将一个或多个文件移动到指定目录dir中|
|ps|列出活动进程的信息|
|pwd|显示出当前工作目录的路径|
|rm file(s)|删除一个或多个文件|
|rmdir dir(s)|删除一个或多个目录|
|sort file(s)|将一个或多个文件中的行进行排序，如果没有指定文件，则对标准输入内容进行排序|
|wc file(s)|统计一个或多个文件中的行数、单词数和字符数，如果没有指定文件的话，则统计标准输入中的内容|
|who|显示出已登录的用户|

关于这些命令的用法，详见：[常用Shell命令](/post/常用Shell命令)

# 基础概念

## 程序（命令）执行

Shell会根据输入的内容进行分析，然后决定执行什么操作。Shell是按行进行分析的，每行都遵循以下的基本格式：

```sh
command [argument1] [argument2] ...
```

Shell使用空白字符（whitespace characters，包括空格符、水平制表符和换行符）来确定命令名称和每个参数的起止，连续的多个空白字符会被Shell忽略。

Shell会扫描命令行，提取行首到第一个空白字符之间的所有内容作为待执行的命令名称command，随后的空白字符（多余的空格）会被忽略，直到下一个空白字符之间的字符作为第一个参数argument1，再到下一个空白字符之间的字符作为第二个参数argument2，如此继续直到该命令行结束。解析完命令行之后，Shell就开始执行命令名称指定的程序，并将命令名称之后的参数传递给该程序

## 文件名替换
Shell在确定要执行的命令及其参数之前，会扫描命令行，查找文件名替换字符*、？或[...]

|替换字符|说明|
|:---:|---|
|*|匹配零个或多个字符|
|?|仅能匹配单个字符|
|[chars]/[char1-char2]|匹配指定字符集合中的某个字符|

## I/O重定向
Shell会扫描每一个命令行，从中找出特殊的重定向字符<、>、2>、<<、>>和2>>。

|重定向字符|说明|
|:---:|---|
|>|将命令行中的下一个单词作为标准输出重定向所指向的文件名|
|<|将命令行中的下一个单词作为标准输入重定向所指向的文件名|
|>>|同>|
|<<|同<|

## 管道
Shell在扫描命令行时，会查找管道字符|。每找到一个，就会将之前命令的标准输出连接到之后命令的标准输入。

## 标准错误
所有运行的Shell命令，都会有默认3个文件描述符:
- 标准输入（stdin，即standard input，文件描述符0）：命令的输入，默认指向键盘
- 标准输出（stdout，即standard output，文件描述符1）：命令执行结果的输出，默认指向终端（屏幕）
- 标准错误（stderr，即standard error，文件描述符2）：命令错误信息的输出，默认指向终端（屏幕）

标准错误默认是同终端或终端应用程序相关联的。标准错误无法通过输出重定向字符（>或>>）写入文件，必须使用特殊的输出重定向字符（2>或2>>）才能将其写入文件。

## 命令（脚本）文件
Shell命令可以直接在终端命令行中输入。也可以从文件中读取，然后由Shell执行该文件。在命令行中执行脚本之前，必须将文件权限修改为可执行：

```sh
$ chmod +x file(s)
```

然后执行该文件

```sh
$ file
```

**注意：如果解决了权限问题，仍旧得到错误信息“command not found”，尝试在命令文件前面加上./（如./file），确保Shell除了在常用的系统位置之外，也会在当前目录下查找命令。要想一劳永逸的话，把.添加到PATH环境变量（通常在.profile文件中）内容的末尾**

在Shell命令文件中使用#作为注释符，Shell会忽略#之后的内容

## 变量

### 变量赋值
Shell允许将值赋值给变量。变量名以字母或下划线开头，后面可以跟上零个或多个字母及数字字符或下划线，可以用正则表达式[A-Za-z_][a-zA-Z0-9_]*来匹配变量名。要将值保存在变量中，要先写出变量名，然后紧跟上等号=，接着是要存入变量的值：

```sh
$ variable=value
```

**注意：**
- Shell变量赋值等号的两边不能有空格
- Shell没有数据类型的概念，无论给Shell变量名分配什么样的值，Shell都简单地将其视为字符串

### 未定义变量
没有值的变量叫做未定义变量，未定义变量的值为null。Shell在扫描命令行时，会先执行替换操作，然后会忽略null。如果想将某个变量的值初始化为空值，只需要把等号右侧留空或者使用两个连续的引号就行：

```sh
$ variable1=
$ variable2=""
$ variable3=''
```

### 变量替换
只要变量名出现在美元符号&#36;之后，Shell就会将其替换成对应的变量值：

```sh
$ echo $variable
value
```
**注意：**
- 在对变量赋值时，Shell并不执行文件名替换
- Shell扫描命令行时，先执行变量替换，然后是文件名替换，接着是将命令行解析成参数（Shell是在执行命令前进行变量替换的，所以即使是命令名也可以保存在变量中）

如果需要对替换后的变量值做特殊处理，比如加上字符X，则必须使用&#36;{variable}结构：

```sh
$ filename=test
// 将文件test重命名为testX
$ mv $filename ${filename}X
```

## 算术扩展
所有POSIX标准Shell提供一种叫做算术扩展（arithmetic expansion）的机制，能够用于执行Shell变量的整数运算。算术扩展的格式为：

```sh
$((expression))
```

其中expression是包含有效的Shell变量（不需要使用美元符号，但必须包含数字值，值的首部和尾部可以有空白字符。如果变量未定义或包含空串，其值被视为0）和操作符（与C语言中的运算符一样）的算术表达式。

也可以使用数学等式解算器[expr](/post/常用Shell命令/#expr)（mathematical equation solver）命令对算术表达式进行运算。使用此命令时操作数和操作符之间必须用空格分隔。

**注意：expr只能够求值整数算术表达式，如果要进行浮点数运算的话，可以使用[awk](/post/常用Shell命令/#awk)或[bc](/post/常用Shell命令/#bc)**

## 引用

Shell能够识别4种不同的引用字符：单引号'、双引号"、反斜线\、反引号`（单引号、双引号和反引号必须成对出现）。

### 单引号
只要Shell碰到第一个'，在遇到用于封闭的'之前，它不会再解释任何特殊字符（即使是Enter键也会被保留并作为命令参数的一部分）。

```sh
$ echo 'How are you today,
> John'
How are you today,
John
$
```

**注意：此处的>叫做辅助提示符（secondary prompt character），Shell会在等待用户完成多行命令的输入时显示该提示符**

### 双引号
双引号会忽略美元符号&#36;、反引号`、反斜线\这3个字符之外的特殊字符。

```sh
$ filelist=*
$ echo $filelist
test.txt test1.txt test2.txt
$ echo '$filelist'
$filelist
$ echo "$filelist"
*
$
```

**双引号还可以用来保留单引号，反之亦然**

### 反斜线
- 反斜线作为前缀使用时在功能上相当于在单个字符周围放置单引号（反斜线可以对紧随其后的字符进行转义）。
- 如果反斜线是输入行的最后一个字符，Shell将其视为续航符（它会删除随后的换行符，也不会将该换行符作为参数分隔符，就好像这个字符从没出现过）
- 在双引号中使用反斜线可以去除会被Shell解释的那些字符的特殊含义（反斜线、美元符号、反引号、换行符以及其他的双引号）。如果反斜线出现在双引号中其他字符之前，Shell会将该反斜线忽略，继续往后处理

### 反引号
反引号也被称为“反撇号”，它告诉Shell将其中的命令使用命令输出代替（命令输出会被插入到它的当前所在位置）。其格式为：

```sh
`command`
```

所有现代POSIX兼容的Shell都支持一种新的命令替换写法（括号中可以调用多个命令，命令之间使用分号隔开，可以使用管道）：

```sh
$(command)
```

## 参数传递

### 变量&#36;1~&#36;{n}
执行Shell程序时，Shell会自动将第n个参数保存在特殊的Shell变量（这些特殊变量叫位置参数，因为它们是基于参数在命令行中所处的位置）&#36;{n}中，这些特殊变量是在Shell完成正常的命令行处理之后（I/O重定向、变量替换、文件名替换等）被赋值的。

```sh
$ cat ./myScript
echo $1 $2
$ ./myScript param1 param2
param1 param2
```

**注意：如果给程序提供的参数多余9个，第10个以后的参数（含第10个），必须使用&#36;{n}的变量形式(否则Shell会把&#36;10替换成&#36;1的值并在后面加上一个0）。你也可以理解为标准形式就是&#36;{n}，当n是个位数时可以省略大括号{}。**

### 变量&#36;#
特殊Shell变量&#36;#包含了命令行中输入的参数个数

```sh
$ cat ./myScript
echo $#
$ ./myScript param1 param2
2
```

### 变量&#36;*
特殊Shell变量&#36;*引用的是传给程序的所有参数，即&#36;1、&#36;2...

```sh
$ cat ./myScript
echo $*
$ ./myScript param1 param2
param1 param2
```

### 变量&#36;@
同&#36;\*，如果使用变量"&#36;@"，则其传入程序中的值是"&#36;1"、"&#36;2"...如果没有了双引号，该变量的效果与&#36;*无异

```sh
$ cat ./myScript
echo $@
$ ./myScript param1 param2
param1 param2
```

### 变量&#36;?
Shell会将变量&#36;?自动设置为最后一条命令的退出状态（对一些命令来说，其表示“执行失败”的数值在不同的系统版本中并不相同，但表示执行成功的退出状态总是0）

```sh
$ cp nosuch backup
cp: cannot access nosuch
$ echo $?
2
```

### 变量&#36;&#36;
Shell会将&#36;&#36;替换成登录Shell的进程ID号

```sh
$ echo $$
6337
$ ps
	  PID TTY           TIME CMD
	 6337 ttys001    0:01.69 -bash
```

## 条件语句
### if、elif、else语句
一般格式为：

```sh
if command1
then
	command
	...
elif command2
then
	command
	...
else
	command
	...
fi
```

### case语句
一般格式为：

```sh
case value in
pattern1) command
			command
			...
			command;;
pattern2) command
			command
			...
			command;;
...
pattern3) command
			command
			...
			command;;
esac			
```

### 退出状态
每一个命令执行完成，就会向Shell返回一个退出状态码。这个退出状态码是一个数值，指明了运行是否成功。为0的退出状态码表示运行成功；非0的退出状态码表示运行失败，不同的值对应不同的失败原因。

### test命令
```sh
test expression
```

另外一种格式为（在“[”之后以及“]”之前必须有空格）：

```sh
[ expression ]
```

### exit命令
exit命令可以立即终止Shell程序的执行，其一般格式为

```sh
exit n
```

其中，n是返回的退出状态码，如果没有指定，则使用在exit之前最后执行的那条命令的退状态（即exit &#36;?）

**注意：如果直接在终端中执行exit命令，会使你登出系统，因为它相当于终止了你的登录Shell**

### &&和||
```sh
command1 && command2
```

如果command1命令返回的退出状态码为0（成功），则接着执行command2。如果command1返回的退出状态码不为0（失败），command2会被忽略。

```sh
command1 || command2
```

command2命令仅在command1命令的退出状态码非0的时候才执行。

## 循环语句

### for命令
```sh
for var (in word1 word2 ... wordn)
do
	command
	...
done
```

do与done之间的命令叫做循环体，其执行的次数由in后面的列表条目个数而定。在执行循环时，word列表中的值分别赋给变量var，然后执行循环体。

**注意：使用for命令时，若忽略in以及后续的列表，则默认使用in "&#36;@"**

### while命令
```sh
while command0
do
	command
done
```

只要command0表达式返回非0，则退出循环。

### until命令
```sh
until command0
do
	command
done
```

只要command0表达式返回0，则退出循环。

### break命令
在循环体中使用break命令可以立即退出循环语句。使用下面的形式，可以立即退出第n层内循环。

```sh
break n
```

### continue命令
类似于break，不同的地方在于它不会退出整个循环，而只是跳过当前迭代中剩下的命令，然后程序立即进入下一次迭代。continue后面也可以加上一个可选的数字，用以跳过最内侧的n个循环中的命令。

```sh
continue n
```

### 循环上的I/O重定向
在循环关闭语句done之后，可以使用重定向操作符进行输出重定向。

### getopts命令
```sh
getopts options option
```

**options**：单字母选项组成的字符串，如果该选项需要参数，则要在后面加上冒号（如ab:c表示-a、-b、-c，-b需要另外指定参数）
**option**：用来存放每个匹配值的变量名

在每次循环中，getopts都会检查下一个命令行参数，通过查看该参数是否以减号开头，随后是否是在options中指定的字符来决定选项是否有效。如果没有问题，getopts就会将匹配的选项字母保存在指定的option中，然后返回为0的退出状态码。如果减号后面的字符没有在options中列出，getopts会返回非0的退出状态码。

- 如果getopts没有在选项后找到要求的参数，它会将问号保存到变量中并向标准错误中输出错误信息。否则，就将选项字符保存在变量中，把用户指定的参数放在一个叫做OPTARG的特殊变量中。
- 特殊变量OPTIND的初始值为1，随后每当getopts返回时都会被更新为下一个要处理的命令行参数的序号。

## 数据的读取和打印
### read命令
```sh
read variables
```

该命令执行时，Shell会从标准输入中读取一行，然后将单词分配给variables中列出的变量。如果行中的单词多于列表中的变量，则多出的单词全部分配给最后一个变量。

**除非碰到文件结尾，read都返回0的退出状态码。如果是从终端读取数据，意味着用户键入Ctrl+d，如果是从文件读取数据，意味着文件中已经没有数据可读了。**

### printf命令
```sh
printf "format" arg1 arg2 ...
```

format是一个字符串，用于详细描述后续数值的显示格式（因为格式化字符串要作为单个参数，且有可能会包含特殊字符和空格，因此最好将其放入引号中）。

# 环境
## 局部变量
当登录Shell执行某个命令或程序时，它会启动一个新的Shell来执行程序。只要新的Shell一启动，就会拥有自己的环境以及一组局部变量。子Shell无法获知或修改登录Shell（父Shell）赋值的那些局部变量。

## 导出变量
可以使用export命令将变量导出，使子Shell获知变量的值。格式如下：

```sh
export variables
```

其中variables是要导出的变量名列表，已导出变量的值会传到export命令之后的所有字Shell中。

**注意：子Shell既不能改变局部变量的值，也不能改变导出变量的值。实际上，只要导出变量进入到子Shell中，它们就成为了局部变量。**

- 未被导出的变量都是局部变量，子Shell并不知道这些变量的存在
- 导出的变量及其值会被复制到子Shell的环境中，在其中可以访问并修改这些导出变量。但是这些修改不会影响到父Shell中的变量
- 导出变量不仅仅保持在直接生成的子Shell中，对于这些子Shell所生成的子Shell也不例外
- 变量可以在赋值前后随时导出，但是只取其到处时的值，不再理会之后做出的改变

```sh
export -p
```

## PS1和PS2
- **PS1**：用于保存命令行提示符字符序列的环境变量
- **PS2**：用于保存辅助命令行提示符（当命令行上的输入长度多余一行时）字符序列的环境变量

**注意：一旦登出系统，所有对于命令行提示符作出的改变就失效了，除非将PS1或PS2的新值添加到.profile文件**

## HOME
主目录是用户登录系统后所处的位置。特殊的Shell变量HOME会在用户登录时自动设成该目录。

**注意：不要轻易修改HOME变量，这么做有可能影响到依赖于该变量的程序**

## PATH
用来搜索用户命令的目录列表保存在Shell变量PATH中，目录之间以冒号（:）分隔，Shell会从左到右依次在目录中查找指定的命令或程序。

**警告：处于安全考虑，不要讲当前目录放在最先搜索的位置**

## 当前目录
当前目录也是Shell环境的一部分。调用cd时，除了会修改当前目录，还会将变量PWD设置为新的当前目录的完整路径，同时还将变量OLDPWD设置为前一个当前目录的完整目录。

**注意：没有办法在子Shell中改变父Shell的当前目录**

## CDPATH
CDPATH指定了一个目录列表，当执行cd命令时，由Shell对其进行搜索（仅在没有给出目录的完整路径且CDPATH不为空的时候才会展开这个搜索）。

**注意：CDPATH并不会在登录时自动设置好，你得明确地将其设置为一系列目录，以便Shell来搜索指定的目录名**

## 子Shell
### .命令
```sh
. file
```

该命令可以在当前Shell中执行file的内容。也就是说，file中的命令就像是直接输入的一样，由当前Shell执行，而不是在子Shell中。

### exec命令
```sh
exec program
```

该命令可以使用新程序替换现有的程序；还可以用来重新分配标准输入或标准输出：

```sh
exec < infile

exec > report
```

要将标准输入重新分配回终端，可以使用命令：

```sh
exec < /dev/tty
```

### (...)和{ ...; }
- **(...)**：在子Shell中执行命令
- **{ ...; }**：在当前Shell中执行命令（如果花括号中的命令全写在同一行上，左花括号后一定要有一个空格，分号必须出现在最后一个命令的末尾）

```sh
(cd bin; ls)

{ cd bin; ls; }
```

**两种括号可以配合管道及I/O重定向使用**

### 将变量传给子Shell
如果想将变量的值送入子Shell，可以在命令行上，把一个或多个变量的赋值放到命令的前面。

```sh
DBHOME=/kevin/data DBID=321 run
# 相当于
(DBHOME=/kevin/data; DBID=321; export DBHOME DBID; run)
``` 

### .profile文件
登录Shell会在系统中查找并读取两个特殊文件：/etc/profile和.profile。相当于执行以下命令：

```sh
$ . /etc/profile
$ . .profile
$
```

- **/etc/profile**：由系统管理员所设置，该文件通常会检查你是否有新的邮件、设置默认的文件创建掩码（umask）、建立默认的PATH以及其他管理员希望登录时完成的工作。
- **$HOME/.profile**：系统在创建账户的时候会会设置一个.profile文件，用户可以修改该文件，使其包含在登录时要执行的命令，甚至覆盖/etc/profile中建立好的设置。

### TERM变量
TERM变量用于保存终端设置及功能的详细信息。Mac OS X系统中TERM的默认值为xterm-256color。

### TZ变量
TZ变量决定当前时区。最简单TZ的设置是由时区名（长度至少位3个字符）和一个数字（指定了小时数，本地时区在经度0以西为正数，本地时区在经度0以东为负数）组成的，小时数必须和本地时间相加来形成世界协调时（Coordinated Universal Time），又称为格林威治标准时间（Greenwich Mean Time）。数字后可以跟上第二个时区名，如果指定的话，表示应用夏令时（daylight saving time），意味着比标准时间早一个小时。如果夏令时时区后还有另外一个数字，该值用来从世界协调时中计算夏令时。date命令会根据TZ计算出正确的时间并使用时区名作为输出，如果没有设置TZ，则使用系统特定的默认时区，一般是世界协调时。

```sh
$ TZ=EST5EDT date
2018年 5月30日 星期三 04时04分43秒 EDT
```

# 参数

参数包括传递给程序的参数（位置参数）、特殊的Shell变量（如$#和$?）及普通变量（关键字参数）。位置参数不能直接赋值，但可以通过set命令重新赋值。给变量赋值方式如下：

```sh
variable=value variable=value ...
```

## 参数替换
### &#36;{parameter}
参数替换最简单的形式是在参数前加上美元符号

- 如果参数名后的字符可能会造成名字冲突，可以把参数名放进花括号内。
- 要访问10以上的位置参数，必须将数字放进花括号中。

#### &#36;{parameter:-value}
如果parameter不为空，则使用它的值；否则，就使用value。

#### &#36;{parameter:=value}
如果parameter不为空，则使用它的值；否则，就使用value并将其分配给parameter（parameter不能是位置参数，因为不能给位置参数赋值）。

执行完替换操作后，Shell会尝试执行替换结果，如果要将其作为单独的命令，需要使用空命令（在Shell程序的条件语句或echo语句中，通常在第一次引用变量的时候会使用:=写法）。

```sh
: ${parameter:=value}	#进行替换（求值），但是什么都不执行0
```

#### &#36;{parameter:?value}
如果parameter不为空，则使用它的值；否则，就将value写入到标准错误，然后退出（如果是在登录Shell中完成该操作，不会登出系统）。如果没有提供value，Shell会输出默认的错误信息：

```sh
prog: parameter: parameter null or not set
```

#### &#36;{parameter:+value}
如果parameter不为空，则替换成value；否则，不进行任何替换。效果和“:-”相反。

#### 模式匹配
模式匹配接受两个参数：变量名（或者是参数数量）和模式。Shell会在指定变量的内容中匹配所提供的模式。如果能够匹配，则在命令行中使用该变量的值（不包括模式所匹配的那部分内容）；如果无法匹配，则使用变量的全部内容。在两种情况下，都不会修改变量的内容。

- **&#36;{variable&#37;pattern}**：检查variable是否以指定的pattern结束。如果是，则使用variable的内容并从其右侧删除pattern所能匹配到的最短结果
- **&#36;{variable&#37;&#37;pattern}**：检查variable是否以指定的pattern结束。如果是，则使用variable的内容并从其右侧删除pattern所能匹配到的最长结果（仅在pattern中使用了*的时候，否则效果与&#36;{variable&#37;pattern}相同）
- **&#36;{variable&#35;pattern}**：使用variable的内容并从其左侧删除pattern所能匹配到的最短结果
- **&#36;{variable&#35;&#35;pattern}**：使用variable的内容并从其左侧删除pattern所能匹配到的最长结果（仅在pattern中使用了*的时候，否则效果与&#36;{variable&#35;pattern}相同）

#### &#36;{&#35;variable}
返回变量中保存的字符个数

### &#36;0变量
Shell会自动将程序名保存在特殊变量&#36;0中。&#36;0基于的是实际的程序文件名，而非程序中的硬编码。有些UNIX系统会将&#36;0设置成包含目录的完整路径，可以使用&#36;(basename &#36;0)来去除路径

### set命令
set命令的作用：设置各种Shell选项以及重新为位置参数&#36;1、&#36;2...赋值

### IFS变量
IFS包含了一组用作空白分隔符的字符，当Shell解析read命令输入、命令替换（反引号机制）输出以及执行变量替换时，会使用该变量作为判断空白字符（也就是作为单词分隔符）的依据

**注意：如果打算在自己的程序中修改IFS，明智的做法是先将旧的IFS值保存在另一个变量（如OIFS），等执行完操作后再恢复**

### readonly命令
用于指定在程序随后的执行过程中，值都不会发生改变的那些变量。如果之后试图给这些变量赋值，Shell就会发出错误信息

**注意：变量的只读属性不会往下传递给子Shell。另外，只要在Shell中将变量设为只读，就无法撤销**

### unset命令
使用unset可以从环境中删除某个变量，但不能对只读变量和IFS、MAILCHECK、PATH、PS1和PS2等使用unset

# 拓展
## eval命令
把eval放在命令行之前，Shell会对其进行二次扫描，然后执行。因此eval常用于从变量中构造命令行，也可以用来创建指向变量的“指针”。

```sh
eval command-line
```

## wait命令
使用wait命令等待后台进程结束后再继续往下执行其他任务。

```sh
wait process-id
```

## &#36;!变量
&#36;!表示最近移入后台的进程ID。

## trap命令
通过trap命令可以监听信号并对其进行处理

```sh
trap commands signals
```

其中commands是接收到由signals指定的信号时要执行的一个或多个命令。

### 不使用参数的trap
执行trap时不带参数，会显示出定义过或修改过的所有trap处理程序

### 忽略信号

### 重置信号

## I/O


## 函数


## type命令


# 其他
## 系统的“垃圾桶”
/dev/null是一个特殊的系统文件，任何人都可以读取（立刻会得到一个EOF）或写入。向该文件写入的任何东西都会消失，就像是一个巨大的黑洞一样。

```sh
ls -c > /dev/null
```

## 终端程序
/dev/tty总是指向终端程序，不管是Mac、Linux还是Unix系统。

```sh
ls -c > /dev/tty
```

## 调试选项 -x
想调试Shell程序，或是了解更多的工作原理，可以在程序正常的调用（命令名及参数）之前输入sh -x以跟踪执行过程（命令在执行的同时会被打印在终端中，并在之前加上一个加号）。

```sh
sh -x cp book book2
```

## 空命令:
该命令什么都不做，它用来满足必须有命令存在的要求。

```sh
if command0
then
	:
else
	command
fi
```

## 续行符\
当\用于行尾的时候表示续行。

```sh
cp book book2 book3 \
book4 dir
```

## 后台运行符&
当&用于行尾的时候表示在后台运行该程序或命令（默认情况下，从系统登出时，所有的进程都会自动终止。如果希望某个程序在登出后仍然继续执行，可以使用nohup命令运行该程序，或者使用at/cron来调度执行）

**循环语句也可以在后台执行，只需要在done语句后加上一个&就可以了**

```sh
for var in 1 2 3
	echo var
done &
```

**PS：待补充更新...**

**欢迎转载，转载请注明出处：[曾华经的博客](http://www.huajingzeng.com)**
